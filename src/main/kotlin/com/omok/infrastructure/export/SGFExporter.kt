package com.omok.infrastructure.export

import com.omok.domain.model.*
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * SGF (Smart Game Format) 내보내기 기능
 * 오목 게임 기보를 SGF 형식으로 변환
 */
class SGFExporter {
    
    companion object {
        private const val SGF_VERSION = "4"
        private const val GAME_TYPE = 16 // Gomoku/Renju
        private const val BOARD_SIZE = 15
    }
    
    /**
     * 게임을 SGF 형식 문자열로 변환
     */
    fun exportToSGF(game: Game): String {
        val sb = StringBuilder()
        
        // SGF 헤더 시작
        sb.append("(;")
        
        // 필수 프로퍼티
        appendProperty(sb, "FF", SGF_VERSION) // File Format
        appendProperty(sb, "GM", GAME_TYPE.toString()) // Game Type (Gomoku)
        appendProperty(sb, "SZ", BOARD_SIZE.toString()) // Board Size
        
        // 게임 정보
        appendGameInfo(sb, game)
        
        // 게임 룰 정보
        appendRuleInfo(sb, game.getSettings())
        
        // 게임 결과
        appendResult(sb, game)
        
        // 수순 기록
        appendMoves(sb, game.getMoveHistory())
        
        // SGF 종료
        sb.append(")")
        
        return sb.toString()
    }
    
    private fun appendProperty(sb: StringBuilder, property: String, value: String) {
        sb.append(property).append("[").append(escapeValue(value)).append("]")
    }
    
    private fun appendGameInfo(sb: StringBuilder, game: Game) {
        val now = LocalDateTime.now()
        val dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
        val timeFormatter = DateTimeFormatter.ofPattern("HH:mm:ss")
        
        // 날짜
        appendProperty(sb, "DT", now.format(dateFormatter))
        
        // 애플리케이션 정보
        appendProperty(sb, "AP", "Renju Gomoku:2.0")
        
        // 플레이어 정보
        val settings = game.getSettings()
        when (settings.mode) {
            GameMode.PLAYER_VS_PLAYER -> {
                appendProperty(sb, "PB", "Player (Black)")
                appendProperty(sb, "PW", "Player (White)")
            }
            GameMode.PLAYER_VS_AI -> {
                appendProperty(sb, "PB", "Player")
                val aiLevel = when (settings.aiDifficulty) {
                    AIDifficulty.EASY -> "Easy"
                    AIDifficulty.MEDIUM -> "Medium"
                    AIDifficulty.HARD -> "Hard"
                    null -> "Unknown"
                }
                appendProperty(sb, "PW", "AI ($aiLevel)")
            }
        }
        
        // 시간 제한 정보
        if (settings.timeLimit.mode != TimeLimitMode.NONE) {
            val timeInfo = formatTimeLimit(settings.timeLimit)
            appendProperty(sb, "TM", timeInfo)
        }
        
        // 게임 코멘트
        val comment = buildString {
            append("Generated by Renju Gomoku v2.0\\n")
            append("Game Rule: ${settings.gameRule.displayName}\\n")
            append("Mode: ${settings.mode.name}\\n")
            if (settings.mode == GameMode.PLAYER_VS_AI) {
                append("AI Difficulty: ${settings.aiDifficulty?.name}\\n")
            }
            append("Date: ${now.format(dateFormatter)} ${now.format(timeFormatter)}")
        }
        appendProperty(sb, "C", comment)
    }
    
    private fun appendRuleInfo(sb: StringBuilder, settings: GameSettings) {
        // 룰 정보를 코멘트로 추가
        val ruleDescription = when (settings.gameRule) {
            GameRule.STANDARD_RENJU -> "Standard Renju rules with forbidden moves for black"
            GameRule.OPEN_RENJU -> "Open Renju rules with 5th move selection"
            GameRule.FREESTYLE -> "Freestyle Gomoku without forbidden moves"
            GameRule.CARO_RULE -> "Caro rules allowing overlines"
            else -> "Renju variant with specific opening rules"
        }
        
        appendProperty(sb, "RU", settings.gameRule.name)
        appendProperty(sb, "GN", "Renju Game - ${settings.gameRule.displayName}")
    }
    
    private fun appendResult(sb: StringBuilder, game: Game) {
        when (val state = game.getState()) {
            is GameState.Won -> {
                val result = when (state.winner) {
                    Player.BLACK -> "B+Win"
                    Player.WHITE -> "W+Win"
                }
                appendProperty(sb, "RE", result)
            }
            is GameState.Draw -> {
                appendProperty(sb, "RE", "Draw")
            }
            else -> {
                // 게임이 진행 중이거나 다른 상태
                appendProperty(sb, "RE", "Unknown")
            }
        }
    }
    
    private fun appendMoves(sb: StringBuilder, moves: List<Move>) {
        for (move in moves) {
            sb.append(";")
            
            val player = when (move.player) {
                Player.BLACK -> "B"
                Player.WHITE -> "W"
            }
            
            val coordinate = positionToSGF(move.position)
            appendProperty(sb, player, coordinate)
        }
    }
    
    /**
     * Position을 SGF 좌표로 변환
     * SGF에서는 좌상단이 (a,a)이고, 오목에서는 (0,0)
     */
    private fun positionToSGF(position: Position): String {
        val col = ('a' + position.col).toString()
        val row = ('a' + position.row).toString()
        return col + row
    }
    
    /**
     * SGF 좌표를 Position으로 변환 (재생 시 사용)
     */
    fun sgfToPosition(sgfCoord: String): Position? {
        if (sgfCoord.length != 2) return null
        
        val col = sgfCoord[0] - 'a'
        val row = sgfCoord[1] - 'a'
        
        return if (col in 0 until BOARD_SIZE && row in 0 until BOARD_SIZE) {
            Position(row, col)
        } else null
    }
    
    private fun formatTimeLimit(timeLimit: TimeLimit): String {
        return when (timeLimit.mode) {
            TimeLimitMode.NONE -> "No limit"
            TimeLimitMode.TOTAL_TIME -> "${timeLimit.totalTimePerPlayer}s total"
            TimeLimitMode.FISCHER -> "${timeLimit.totalTimePerPlayer}s + ${timeLimit.incrementPerMove}s/move"
            TimeLimitMode.BYOYOMI -> "${timeLimit.totalTimePerPlayer}s + 3x${timeLimit.incrementPerMove}s"
        }
    }
    
    private fun escapeValue(value: String): String {
        return value
            .replace("\\", "\\\\")
            .replace("]", "\\]")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("\t", "\\t")
    }
    
    /**
     * SGF 파일에서 게임 정보 추출 (미래 확장용)
     */
    data class SGFGameInfo(
        val gameType: Int,
        val boardSize: Int,
        val blackPlayer: String?,
        val whitePlayer: String?,
        val result: String?,
        val date: String?,
        val rules: String?,
        val comment: String?,
        val moves: List<Pair<Player, Position>>
    )
    
    /**
     * 파일 확장자 검증
     */
    fun isValidSGFExtension(fileName: String): Boolean {
        return fileName.lowercase().endsWith(".sgf")
    }
    
    /**
     * 기본 SGF 파일명 생성
     */
    fun generateDefaultFileName(game: Game): String {
        val now = LocalDateTime.now()
        val formatter = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
        val settings = game.getSettings()
        
        val modePrefix = when (settings.mode) {
            GameMode.PLAYER_VS_PLAYER -> "PvP"
            GameMode.PLAYER_VS_AI -> "PvAI"
        }
        
        val rulePrefix = when (settings.gameRule) {
            GameRule.STANDARD_RENJU -> "Renju"
            GameRule.OPEN_RENJU -> "OpenRenju"
            GameRule.FREESTYLE -> "Gomoku"
            GameRule.CARO_RULE -> "Caro"
            else -> "RenjuVariant"
        }
        
        return "${rulePrefix}_${modePrefix}_${now.format(formatter)}.sgf"
    }
}